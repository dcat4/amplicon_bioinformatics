---
title: "consensus_tax_mostCom Demo"
author: "K Son"
date: "April 30, 2020"
output: github_document
---

## Overview

Here, we step through implementations of the consensus_tax_mostCom.R algorithm to demonstrate proper uses and anticipated results. This algorithm is built to utilize information from multiple taxonomy tables (defined here as a table of ASVs and correspnding taxonomic assignments) in order to improve the resolution and/or accuracy of taxonomic annotations of amplicon sequences. It incorporates information from multiple taxonomy tables and determines a "consensus taxonomy" for each ASV in your data set. The algorithm requires that all taxonomy tables follow the same taxonomic naming and ranking conventions, that the order of columns in each taxonomy table follows the taxonomic ranking heirarchy, and that the order of rows (ASVs) in each of the input taxonomy tables is the same. If these rules are not followed, spurious results are likely.

### consensus_tax_mostCom Algorithm Description

consensus_tax_mostCom generates a consensus taxonomy by using the most frequent taxonomy starting at the most specific ranking across all user-specified input taxonomy tables. In other words, it's designed to get the the taxonomic annotation where it is the majority among other taxonomic assignments. Unresolved taxonomic assignments in each taxonomy table should be indicated by NA as there is a parameter for the algorithm to consider NA as a taxonomic assignment or not. There will be occasions when multiple input taxonomy tables are 'tied' for the most frequeny taxonomy for a given ASV; thus, after assigning a consensus taxonomy to the ASVs where a single taxonomy provides the most common taxonomy, the algorithm uses a series of user-speicifed rules to break the remaining ties. Rules you may specify are demonstarted below. 

### Start 'er up:

We'll clear out our environment, load in the reshape2 package ofr later, set our wd, and read in taxonomy tables: The taxonomy tables used here come from implementations of the RDP Bayesian classifer, the new idtaxa algorithm, and MEGAN'S LCA algorithm against both the Silva and pr2 reference databases. Our amplicon data set is an 18S-V9 tag sequencing project from the coastal ocean. 

You can do this with any taxonomy tables assuming you format them properly. To follow along with this demo, grab the taxonomy tables in the "test_data" directory of this repository and follow the code below.

```{r}
rm(list = ls())

# load up reshape2:
# load up reshape2:
.cran_packages <- c("reshape2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(.cran_packages[!.inst])
}
sapply(c(.cran_packages), require, character.only = TRUE)

# setwd and read in your datasets:
setwd("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/demos_and_validation")

idtax.pr2 <- readRDS("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/idtax_0boot_pr2_all18SAug19.rds")
bayes.pr2 <- readRDS("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/bayes_0boot_pr2_all18SAug19.rds")
bayes.silva <- read.csv("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/bayes_silva_60boot_mapped2pr2_all18SAug19.csv",
                        stringsAsFactors = FALSE)
idtax.silva <- read.csv("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/idtax_silva_0boot_mapped2pr2_all18SAug19.csv",
                        stringsAsFactors = FALSE)
lca.pr2 <- read.csv("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/LCA_pr2_mapped2pr2_all18SAug19.csv",
                        stringsAsFactors = FALSE)
lca.silva <- read.csv("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/test_data/LCA_silva_mapped2pr2_all18SAug19_Fixed.csv",
                    stringsAsFactors = FALSE)
```

### Arranging and formating our taxonomy tables for running the algorithm:

The data we're using was pulled slightly haphazardly, so here we'll use some bootstrapping estimates to NA-out low-confidence assignments, reformat our taxonomy tables as dataframes, and sort them alphabetically by ASV sequences so that the order of rows/ASVs is the same across all taxonomy tables.

```{r}
# convert tax tables to dataframes as needed and sort by seq's to get the same order..:
conf <- as.data.frame(bayes.pr2$boot, stringsAsFactors = FALSE)
bayes.pr2 <- as.data.frame(bayes.pr2$tax, stringsAsFactors = FALSE)
bayes.pr2[conf < 60] <- NA

source("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/helper_fcns/idtax2df.R")
idtax.pr2 <- idtax2df(idtax.pr2, boot = 60)

# sorting each dataframe by DNA sequences:
ii <- sort(rownames(bayes.pr2), index.return = TRUE)
bayes.pr2 <- bayes.pr2[ii$ix,]
idtax.pr2 <- idtax.pr2[ii$ix,]
jj <- sort(bayes.silva$DNASeq, index.return = TRUE)
bayes.silva <- bayes.silva[jj$ix,2:9]
kk <- sort(idtax.silva$Sequence, index.return = TRUE)
idtax.silva <- idtax.silva[kk$ix,3:10]
ll <- sort(lca.silva$Sequence, index.return = TRUE)
lca.silva <- lca.silva[ll$ix,3:10]
mm <- sort(lca.pr2$Sequence, index.return = TRUE)
lca.pr2 <- lca.pr2[mm$ix,3:10]
```

You can run this for a sanity check:

```{r}
# compare the sorted sequence arrays to ensure they're all =:
identical(ii$x, jj$x)
identical(jj$x, kk$x)
identical(kk$x, ll$x)
identical(ll$x,mm$x)
```

...and this to see what the data sets look like. These data sets are available in the test-data directory.

```{r}
# one more check:
head(bayes.pr2, n = 10)
head(bayes.silva, n = 10)
head(idtax.pr2, n = 10)
head(idtax.silva, n = 10)
head(lca.pr2, n = 10)
head(lca.silva, n = 10)
```

The algorithm expects that the ASV's in each taxonomy data frame are all in the same order. Before inputting our tables in the algorithm, we will standardize our `bayes.silva`, `idtax.silva`, and `lca.silva` taxonomies to pr2 using the taxonomy mapping function as well as sort them by svN and ASV's.

```{r}
source("~/Desktop/Taxonomic Sequencing/amplicon_bioinformatics/taxonomy_pipeline/tax_table_mapping/taxmapper.R")

synonym.filepath <- "~/Desktop/Taxonomic Sequencing/amplicon_bioinformatics/taxonomy_pipeline/tax_table_mapping/tax_synonyms_FINAL.csv"

# Bacteria and Archaea doesn't exist in pr2
nonexistent <- c('Bacteria', 'Archaea')

pr2 <- read.csv("~/Desktop/Taxonomic Sequencing/amplicon_bioinformatics/taxonomy_pipeline/tax_table_mapping/pr2_all_tax.csv")
pr2 <- pr2[,-1]

bayes.silva.2.pr2 <- taxmapper(taxin=bayes.silva, tax2map2=pr2, 
                               exceptions=nonexistent,
                               synonym.file=synonym.filepath)

idtax.silva.2.pr2 <- taxmapper(taxin=idtax.silva, tax2map2=pr2, 
                               exceptions=nonexistent,
                               synonym.file=synonym.filepath)
lca.silva.2.pr2 <- taxmapper(taxin=lca.silva, tax2map2=pr2, 
                               exceptions=nonexistent,
                               synonym.file=synonym.filepath)

bayes <- bayes.silva.2.pr2[[3]]
idtax <- idtax.silva.2.pr2[[3]]
lca <- lca.silva.2.pr2[[3]]

s.bayes <- bayes[sort(as.character(bayes$svN), index.return=TRUE)$ix, ]
s.idtax <- idtax[sort(as.character(idtax$svN), index.return=TRUE)$ix, ]
s.lca <- lca[sort(as.character(lca$svN), index.return=TRUE)$ix, ]
```


### First run

Our data should be good to go, so let's run the algorithm. We have to specify names for our taxonmy tables in a character vector. We won't specify rank names b/c the defaults work for us. There is an option for the algorithm to count the term NA as part of the majority computation. In this case, we'll count it. 

First we'll tell R where to find the algorithm and load it into our session. In our first run, we'll specify no tie-breakers, so that the algorithm will only assign consensus taxonomies to ASVs where a single taxonomy table has the most common taxonomy of our 3 datasets.

```{r}
source("~/Documents/R/amplicon_bioinformatics/taxonomy_pipeline/consensus_taxonomies/consensus_tax_mostCom2.R")

tblnam <- c("bayes-pr2", "idtax-pr2", "lca-pr2")
test1 <- consensus_tax_mostCom2(s.bayes, s.idtax, s.lca,
                        tablenames = tblnam, count.na=TRUE,
                        tiebreakz = "none")
```

The output is a list with 3 elements. The 1st element is the consensus taxonomy table, the 2nd element is a list of all the input taxonomies, and the third element is a numeric vector containing the row indices of all ASVs that still require tie-breaking. 

In order to show different scenarios of our algorithm resolving the majorities, we've handpicked certain rows to build a subset data frame to showcase our algorithm. 

```{r}
svs <- c("sv24097", "sv14101", "sv15679", "sv19788", "sv22921", "sv9968", "sv19154", "sv17559", "sv19589", "sv17897", "sv17874", "sv104", "sv5216", "sv5759", "sv6408", "sv5605", "sv12184", "sv16779", "sv15370", "sv20943", "sv23365", "sv1509", "sv4792", "sv22976", "sv20635", "sv17488", "sv17511", "sv22291", "sv8232", "sv15734", "sv5756", "sv14822", "sv21647", "sv4356", "sv9792", "sv5337", "sv11054", "sv5272")

mini.b <- s.bayes[which(s.bayes$svN %in% svs), ]
mini.i <- s.idtax[which(s.idtax$svN %in% svs), ]
mini.l <- s.lca[which(s.lca$svN %in% svs), ]

c.test <- consensus_tax_mostCom2(mini.b, mini.i, mini.l, 
                                 tablenames = c("bayes", "idtax", "lca"), 
                                 ranknamez = c("kingdom", "supergroup", "division", "class", "order", "family", "genus", "species"), 
                                 tiebreakz = "none", count.na = TRUE)
```

We've saved the result in a csv file called `bayes_idtax_lca_pr2_mapped.csv` that we will store into a data frame called `consensus.res`. We chunked out each ASV's taxonomic assignments from each of our 3 input taxonomy tables, as well as our consensus taxonomy table, and put them in consecutive rows. This way, we can look at chunks of assignments for the same ASV to `consensus.res` the algorithm and ensure it's doing what we think. 

Here, we'll pop out a few good examples. 

```{r}
consensus.res[1:4, 4:12]
```

The output shows the taxonomic assignments for an arbitrary ASV in 3 of our initial taxonomy tables, as well as our consensus table. The last column shows the taxonomy table of each row for this arbitrary ASV. RESULT deontes our consensus taxonomy. We can see that all of the taxonomies are the same, so it's obvious that the resulting consensus taxonomy should be the same as well.

Now let's look at one where some contain different taxonomies.

```{r}
consensus.res[11:14, 4:12]
```

Here, we can see that the taxonomies in bayes and idtax are the majority in each column compared to the NA taxonomy in LCA. Therefore, the resulting consensus taxonomy would be the taxonomies from bayes and idtax. 

```{r}
consensus.res[81:84, 4:12]
```

We can see that in the Order, Family, and Genus rankings, there is no majority as there is a three way tie between the taxonomy tables. Since we didn't specify a tiebreaker preference, the algorithm automatically assigns NA to that column as it wasn't able to conclude to a consensus. 